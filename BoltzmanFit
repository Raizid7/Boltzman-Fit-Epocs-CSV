import os
import numpy as np
import pandas as pd
import tkinter as tk
from tkinter import filedialog, messagebox
from dataclasses import dataclass

import matplotlib.pyplot as plt
from scipy.optimize import least_squares
from scipy.stats import t as student_t


def boltzmann(x, max_out, x50, k):
    """3-parameter logistic (Boltzmann) function."""
    return max_out / (1.0 + np.exp(-(x - x50) / k))


def peak_to_peak(y):
    """Peak-to-peak amplitude ignoring NaNs."""
    return float(np.nanmax(y) - np.nanmin(y))


def rms_nan(y):
    """RMS ignoring NaNs."""
    y = np.asarray(y, dtype=float)
    y = y[np.isfinite(y)]
    if y.size == 0:
        return float("nan")
    return float(np.sqrt(np.mean(y * y)))


def local_extrema(y):
    """Return indices of local maxima and minima (on the given 1D array)."""
    y = np.asarray(y, dtype=float)
    if y.size < 3:
        return np.array([], dtype=int), np.array([], dtype=int)

    dy = np.diff(y)
    s = np.sign(dy)
    ds = np.diff(s)

    # max: sign goes + to -
    max_idx = np.where(ds < 0)[0] + 1
    # min: sign goes - to +
    min_idx = np.where(ds > 0)[0] + 1
    return max_idx.astype(int), min_idx.astype(int)


def m_amp_p1n1_in_window(t, y, stim_time_ms, m_mask, h_start_ms, opposite_max_ms=12.0):
    """
    M amplitude as first peak to first opposite peak (P1->N1 or N1->P1) inside the M window.

    - Uses the first local extremum within the M window.
    - Then searches for the first opposite extremum after it, but only:
        * up to (first_peak_time + opposite_max_ms)
        * and before the H search starts (h_start_ms)

    Returns NaN if not detectable.
    """
    t = np.asarray(t, dtype=float)
    y = np.asarray(y, dtype=float)
    idx = np.flatnonzero(m_mask)
    if idx.size < 5:
        return float("nan")

    t_seg = t[idx]
    y_seg = y[idx]

    # Time in ms relative to stim
    tr_seg = (t_seg - (stim_time_ms / 1000.0)) * 1000.0

    max_idx, min_idx = local_extrema(y_seg)
    if max_idx.size == 0 and min_idx.size == 0:
        return float("nan")

    # First extremum in time
    if max_idx.size and min_idx.size:
        first = int(max_idx[0] if max_idx[0] < min_idx[0] else min_idx[0])
    elif max_idx.size:
        first = int(max_idx[0])
    else:
        first = int(min_idx[0])

    first_is_max = np.any(max_idx == first)

    # Limit opposite-peak search
    t_first = float(tr_seg[first])
    t_limit = min(float(h_start_ms), t_first + float(opposite_max_ms))
    after = (np.arange(y_seg.size) > first) & (tr_seg <= t_limit)

    cand_after = np.flatnonzero(after)
    if cand_after.size < 3:
        return float("nan")

    if first_is_max:
        opp = np.intersect1d(min_idx, cand_after, assume_unique=False)
        if opp.size == 0:
            # fallback: absolute minimum after first in allowed range
            rel = y_seg[cand_after]
            opp_i = int(cand_after[int(np.argmin(rel))])
        else:
            opp_i = int(opp[0])
    else:
        opp = np.intersect1d(max_idx, cand_after, assume_unique=False)
        if opp.size == 0:
            # fallback: absolute maximum after first in allowed range
            rel = y_seg[cand_after]
            opp_i = int(cand_after[int(np.argmax(rel))])
        else:
            opp_i = int(opp[0])

    amp = y_seg[first] - y_seg[opp_i]
    return float(abs(amp))


@dataclass
class Settings:
    # --- stimulation schedule (manual intensity rule) ---
    stim_start_mv: float = 0.2
    stim_step_mv: float = 0.3
    sweeps_per_step: int = 3

    # --- timing (ms) relative to stim at t=0 ---
    stim_time_ms: float = 0.0

    stim_start_ms: float = -5.0
    stim_stop_ms: float = 5.0

    m_start_ms: float = 10.0
    m_stop_ms: float = 25.0

    h_start_ms: float = 30.0
    h_stop_ms: float = 50.0

    rms_start_ms: float = -90.0
    rms_stop_ms: float = -10.0

    # --- M amplitude method ---
    # If False: classic peak-to-peak within fixed M window.
    # If True : first peak-to-first opposite peak (P1->N1 / N1->P1) within the M window,
    #          which is more robust when later oscillations overlap the M window.
    use_m_p1n1: bool = False

    # Max time (ms) after the first M peak to look for the opposite peak (only used if use_m_p1n1=True)
    m_opposite_max_ms: float = 12.0

    # --- optional small X jitter to avoid duplicate X fit issues ---
    add_x_jitter: bool = True
    x_jitter_sd_mv: float = 0.01

    # --- MATLAB-like extras ---
    show_raw_check_plot: bool = True
    show_h_poly_fit_plot: bool = True
    write_results_txt: bool = True
    results_txt_name: str = "InOutResults.txt"
    save_summary_csv: bool = True
    summary_csv_suffix: str = "_summary.csv"

    # --- confidence intervals ---
    ci_alpha: float = 0.05  # 0.05 => 95% CI


def build_x_manual(n_sweeps, stim_start_mv, stim_step_mv, sweeps_per_step):
    if sweeps_per_step <= 0:
        raise ValueError("sweeps_per_step must be > 0.")
    idx = np.arange(n_sweeps)
    level = idx // int(sweeps_per_step)
    return stim_start_mv + stim_step_mv * level


def masks_from_ms(t, stim_time_ms, start_ms, stop_ms):
    tr = t - (stim_time_ms / 1000.0)
    s0 = start_ms / 1000.0
    s1 = stop_ms / 1000.0
    return (tr >= s0) & (tr <= s1)


def _fit_boltzmann_least_squares(x, y, p0, bounds):
    lower, upper = bounds

    def resid(p):
        return boltzmann(x, *p) - y

    res = least_squares(
        resid,
        x0=np.asarray(p0, dtype=float),
        bounds=(np.asarray(lower, dtype=float), np.asarray(upper, dtype=float)),
        max_nfev=200000,
    )
    return res


def _cov_and_ci_from_jacobian(res, alpha=0.05):
    """Approximate covariance + (1-alpha) CI from least_squares result."""
    r = np.asarray(res.fun, dtype=float)
    J = np.asarray(res.jac, dtype=float)
    m = r.size
    p = J.shape[1]

    if m <= p:
        return None, None

    # residual variance estimate
    s_sq = float(np.dot(r, r) / (m - p))

    # covariance ~ s^2 * inv(J^T J)
    try:
        JTJ = J.T @ J
        cov = np.linalg.inv(JTJ) * s_sq
    except np.linalg.LinAlgError:
        return None, None

    se = np.sqrt(np.diag(cov))
    dof = m - p
    tcrit = float(student_t.ppf(1.0 - alpha / 2.0, dof))
    beta = np.asarray(res.x, dtype=float)
    ci = np.vstack([beta - tcrit * se, beta + tcrit * se]).T
    return cov, ci



def fit_h_reflex_poly3(x, y, normalize=True):
    """Poly3 fit for H-reflex (optionally normalized).

    Returns:
        dict with keys:
          - coeffs_z: poly coefficients highest->lowest in normalized space (z)
          - mu, sigma: normalization parameters (if normalize else 0,1)
          - r2, rmse: goodness-of-fit metrics on the input points
          - x_grid, y_grid: smooth curve for plotting
          - y_hat: fitted values on x
    """
    x = np.asarray(x, dtype=float)
    y = np.asarray(y, dtype=float)
    ok = np.isfinite(x) & np.isfinite(y)
    x = x[ok]
    y = y[ok]
    if x.size < 4:
        raise ValueError("Not enough points for Poly3 fit (need >= 4).")

    if normalize:
        mu = float(np.mean(x))
        sigma = float(np.std(x, ddof=0))
        if not np.isfinite(sigma) or sigma == 0.0:
            sigma = 1.0
        z = (x - mu) / sigma
    else:
        mu, sigma = 0.0, 1.0
        z = x

    coeffs_z = np.polyfit(z, y, deg=3)
    p = np.poly1d(coeffs_z)
    y_hat = p(z)

    ss_res = float(np.sum((y - y_hat) ** 2))
    ss_tot = float(np.sum((y - float(np.mean(y))) ** 2))
    r2 = float("nan") if ss_tot == 0.0 else 1.0 - ss_res / ss_tot
    rmse = float(np.sqrt(ss_res / max(1, y.size)))

    # Smooth curve
    x_grid = np.linspace(float(np.min(x)), float(np.max(x)), 400)
    z_grid = (x_grid - mu) / sigma if normalize else x_grid
    y_grid = p(z_grid)

    return {
        "coeffs_z": coeffs_z,
        "mu": mu,
        "sigma": sigma,
        "r2": r2,
        "rmse": rmse,
        "x_grid": x_grid,
        "y_grid": y_grid,
        "y_hat": y_hat,
        "x_data": x,
        "y_data": y,
    }


def run_fit(csv_path: str, s: Settings):
    # Expect headerless numeric CSV:
    # column 0 = time (seconds)
    # columns 1..N = sweep signals
    df = pd.read_csv(csv_path, header=None)
    arr = df.to_numpy(dtype=float)

    if arr.shape[1] < 3:
        raise ValueError("CSV must be: time column + at least 2 sweep columns.")

    t = arr[:, 0]
    sweeps = arr[:, 1:]
    n_samples, n_sweeps = sweeps.shape

    dt = float(np.median(np.diff(t)))
    if not np.isfinite(dt) or dt <= 0:
        raise ValueError("Time column is invalid (dt<=0).")
    sf = 1.0 / dt

    stim_mask = masks_from_ms(t, s.stim_time_ms, s.stim_start_ms, s.stim_stop_ms)
    m_mask = masks_from_ms(t, s.stim_time_ms, s.m_start_ms, s.m_stop_ms)
    h_mask = masks_from_ms(t, s.stim_time_ms, s.h_start_ms, s.h_stop_ms)
    rms_mask = masks_from_ms(t, s.stim_time_ms, s.rms_start_ms, s.rms_stop_ms)

    for name, m in [("Stim", stim_mask), ("M", m_mask), ("H", h_mask), ("RMS", rms_mask)]:
        if m.sum() < 3:
            raise ValueError(f"{name} window has too few samples.")

    # Stimulation intensities
    X = build_x_manual(n_sweeps, s.stim_start_mv, s.stim_step_mv, s.sweeps_per_step)

    # Optional jitter (deterministic)
    X_fit = X.copy()
    if s.add_x_jitter:
        rng = np.random.default_rng(0)
        X_fit = X_fit + rng.normal(0.0, s.x_jitter_sd_mv, size=X_fit.shape)

    # Extract per-sweep metrics
    Mampx = np.full(n_sweeps, np.nan, dtype=float)
    Hampx = np.full(n_sweeps, np.nan, dtype=float)
    EMGrmsx = np.full(n_sweeps, np.nan, dtype=float)

    for i in range(n_sweeps):
        y = sweeps[:, i]

        # Baseline RMS always from the fixed RMS window
        EMGrmsx[i] = rms_nan(y[rms_mask])

        # H stays classic peak-to-peak in the fixed H window
        Hampx[i] = peak_to_peak(y[h_mask])

        # M: choose method
        if s.use_m_p1n1:
            Mampx[i] = m_amp_p1n1_in_window(
                t=t,
                y=y,
                stim_time_ms=s.stim_time_ms,
                m_mask=m_mask,
                h_start_ms=s.h_start_ms,
                opposite_max_ms=s.m_opposite_max_ms,
            )
        else:
            Mampx[i] = peak_to_peak(y[m_mask])

    # scaling to mV
    scale_to_mV = 1000.0
    Mamp = Mampx * scale_to_mV
    Hamp = Hampx * scale_to_mV
    EMGrms = EMGrmsx * scale_to_mV

    # --- H-Reflex Poly3 fit (..., 'Poly3', 'Normalize','on') ---
    h_poly = None
    if s.show_h_poly_fit_plot:
        try:
            h_poly = fit_h_reflex_poly3(X, Hamp, normalize=True)

            plt.figure()
            plt.plot(h_poly["x_grid"], h_poly["y_grid"], "-", linewidth=1, label="Poly3 fit (normalized)")
            plt.plot(h_poly["x_data"], h_poly["y_data"], "o", label="Hamp vs. X")
            plt.xlabel("Stimulation intensity (mV)")
            plt.ylabel("H amplitude (mV)")
            plt.title(f"H-Reflex (Poly3) | R²={h_poly['r2']:.3f} | RMSE={h_poly['rmse']:.3g}")
            plt.grid(True)
            plt.legend(loc="upper right")
            plt.tight_layout()
        except Exception as _e:
            # Keep main workflow running even if the polynomial fit fails.
            h_poly = None


    # Fit only finite points
    ok = np.isfinite(X_fit) & np.isfinite(Mamp)
    Xv = X_fit[ok]
    Yv = Mamp[ok]
    if Xv.size < 6:
        raise ValueError("Not enough valid sweeps for fit.")

    # Initial guesses (close to MATLAB logic)
    max0 = float(np.nanmax(Yv))
    i_max = int(np.nanargmax(Yv))
    x50_0 = float(Xv[i_max] / 2.0)  # MATLAB used X(I)/2
    x_range = float(np.nanmax(Xv) - np.nanmin(Xv))
    k0 = max(x_range / 10.0, 1e-6)
    p0 = [max0, x50_0, k0]

    pad = 0.25 * (x_range + 1e-9)
    lower = [0.0, float(np.nanmin(Xv) - pad), 1e-9]
    upper = [np.inf, float(np.nanmax(Xv) + pad), np.inf]

    # Fit using least_squares to get residuals + Jacobian
    res = _fit_boltzmann_least_squares(Xv, Yv, p0=p0, bounds=(lower, upper))
    beta = res.x
    R = res.fun
    J = res.jac

    pcov, ci = _cov_and_ci_from_jacobian(res, alpha=s.ci_alpha)

    # Create smooth curve (MATLAB: round(min):0.1:round(max))
    x_grid = np.arange(np.round(float(np.nanmin(Xv))), np.round(float(np.nanmax(Xv))) + 0.0001, 0.1)
    y_grid = boltzmann(x_grid, *beta)

    # --- Raw check plot (Hamp & Mamp vs stim) ---
    if s.show_raw_check_plot:
        plt.figure()
        plt.plot(X, Hamp, "o", label="H-reflex (p-p)")
        plt.plot(X, Mamp, "o", label=("M-wave (P1→N1)" if s.use_m_p1n1 else "M-wave (p-p)"))
        plt.xlabel("Stimulation intensity (mV)")
        plt.ylabel("Amplitude (mV)")
        plt.title("Raw check: H and M vs stimulation")
        plt.legend()
        plt.tight_layout()

    # --- Fit plot ---
    plt.figure()
    plt.plot(x_grid, y_grid, "-", linewidth=1, label="Boltz fit (M)")
    plt.plot(X, Mamp, "o", label=("M-wave (P1→N1)" if s.use_m_p1n1 else "M-wave (p-p)"))
    plt.plot(X, Hamp, "o", label="H-reflex (p-p)")
    plt.xlabel("Stimulation intensity (mV)")
    plt.ylabel("Amplitude (mV)")
    plt.title(f"{os.path.basename(csv_path)}\nSF={sf:.1f} Hz | sweeps={n_sweeps}")
    plt.legend()
    plt.tight_layout()
    plt.show()

    # --- Save results ---
    out_dir = os.path.dirname(os.path.abspath(csv_path))
    txt_path = os.path.join(out_dir, s.results_txt_name)

    if s.write_results_txt:
        with open(txt_path, "a", encoding="utf-8") as f:
            f.write(f"{os.path.abspath(csv_path)}\t")
            f.write("\t".join([f"{v:.8f}" for v in beta]))
            f.write("\n")

    # --- Save per-sweep summary table ---
    summary_path = None
    if s.save_summary_csv:
        base, _ = os.path.splitext(os.path.basename(csv_path))
        summary_path = os.path.join(out_dir, base + s.summary_csv_suffix)
        pd.DataFrame(
            {
                "sweep": np.arange(1, n_sweeps + 1),
                "stim_mv": X,
                "M_pp_mV": Mamp,
                "M_method": ("P1N1" if s.use_m_p1n1 else "P2P"),
                "M_opp_max_ms": (s.m_opposite_max_ms if s.use_m_p1n1 else np.nan),
                "H_pp_mV": Hamp,
                "baseline_rms_mV": EMGrms,
            }
        ).to_csv(summary_path, index=False)

    return {
        "sf": sf,
        "beta": beta,
        "residuals": R,
        "jacobian": J,
        "pcov": pcov,
        "ci": ci,
        "h_poly": h_poly,
        "xstim": x_grid,
        "fit": y_grid,
        "txt_path": txt_path if s.write_results_txt else None,
        "summary_path": summary_path,
        "table": pd.DataFrame(
            {
                "sweep": np.arange(1, n_sweeps + 1),
                "stim_mv": X,
                "M_pp_mV": Mamp,
                "M_method": ("P1N1" if s.use_m_p1n1 else "P2P"),
                "M_opp_max_ms": (s.m_opposite_max_ms if s.use_m_p1n1 else np.nan),
                "H_pp_mV": Hamp,
                "baseline_rms_mV": EMGrms,
            }
        ),
    }


def gui():
    root = tk.Tk()
    root.title("Boltzmann Fit (MATLAB-like extras)")

    s = Settings()

    file_var = tk.StringVar(value="")

    stim_start_var = tk.StringVar(value=str(s.stim_start_mv))
    stim_step_var = tk.StringVar(value=str(s.stim_step_mv))
    sweeps_per_var = tk.StringVar(value=str(s.sweeps_per_step))

    stim_time_var = tk.StringVar(value=str(s.stim_time_ms))
    stim_w1 = tk.StringVar(value=str(s.stim_start_ms))
    stim_w2 = tk.StringVar(value=str(s.stim_stop_ms))
    m_w1 = tk.StringVar(value=str(s.m_start_ms))
    m_w2 = tk.StringVar(value=str(s.m_stop_ms))
    h_w1 = tk.StringVar(value=str(s.h_start_ms))
    h_w2 = tk.StringVar(value=str(s.h_stop_ms))
    rms_w1 = tk.StringVar(value=str(s.rms_start_ms))
    rms_w2 = tk.StringVar(value=str(s.rms_stop_ms))

    # M method option
    m_p1n1_on = tk.IntVar(value=1 if s.use_m_p1n1 else 0)
    m_opp_max_var = tk.StringVar(value=str(s.m_opposite_max_ms))

    jitter_on = tk.IntVar(value=1 if s.add_x_jitter else 0)
    jitter_sd = tk.StringVar(value=str(s.x_jitter_sd_mv))

    raw_plot_on = tk.IntVar(value=1 if s.show_raw_check_plot else 0)
    h_poly_on = tk.IntVar(value=1 if s.show_h_poly_fit_plot else 0)
    write_txt_on = tk.IntVar(value=1 if s.write_results_txt else 0)
    save_csv_on = tk.IntVar(value=1 if s.save_summary_csv else 0)

    def browse():
        p = filedialog.askopenfilename(
            title="Select CSV",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
        )
        if p:
            file_var.set(p)

    def run():
        path = file_var.get().strip()
        if not path:
            messagebox.showerror("Error", "Pick a CSV first.")
            return

        try:
            settings = Settings(
                stim_start_mv=float(stim_start_var.get()),
                stim_step_mv=float(stim_step_var.get()),
                sweeps_per_step=int(float(sweeps_per_var.get())),
                stim_time_ms=float(stim_time_var.get()),
                stim_start_ms=float(stim_w1.get()),
                stim_stop_ms=float(stim_w2.get()),
                m_start_ms=float(m_w1.get()),
                m_stop_ms=float(m_w2.get()),
                h_start_ms=float(h_w1.get()),
                h_stop_ms=float(h_w2.get()),
                rms_start_ms=float(rms_w1.get()),
                rms_stop_ms=float(rms_w2.get()),
                use_m_p1n1=bool(m_p1n1_on.get()),
                m_opposite_max_ms=float(m_opp_max_var.get()),
                add_x_jitter=bool(jitter_on.get()),
                x_jitter_sd_mv=float(jitter_sd.get()),
                show_raw_check_plot=bool(raw_plot_on.get()),
                show_h_poly_fit_plot=bool(h_poly_on.get()),
                write_results_txt=bool(write_txt_on.get()),
                save_summary_csv=bool(save_csv_on.get()),
            )
        except Exception as e:
            messagebox.showerror("Error", f"Bad input: {e}")
            return

        try:
            out = run_fit(path, settings)
            beta = out["beta"]
            ci = out["ci"]

            lines = [
                f"SF = {out['sf']:.2f} Hz",
                "",
                "beta:",
                f"  max_out = {beta[0]:.6g}",
                f"  x50     = {beta[1]:.6g}",
                f"  k       = {beta[2]:.6g}",
            ]

            if ci is not None:
                lines += [
                    "",
                    f"{int((1.0 - settings.ci_alpha) * 100)}% CI:",
                    f"  max_out: [{ci[0,0]:.6g}, {ci[0,1]:.6g}]",
                    f"  x50    : [{ci[1,0]:.6g}, {ci[1,1]:.6g}]",
                    f"  k      : [{ci[2,0]:.6g}, {ci[2,1]:.6g}]",
                ]

            if out.get("txt_path"):
                lines += ["", f"Appended: {out['txt_path']}"]
            if out.get("summary_path"):
                lines += [f"Saved: {out['summary_path']}"]

            messagebox.showinfo("Fit result", "\n".join(lines))

        except Exception as e:
            messagebox.showerror("Error", str(e))

    frm = tk.Frame(root, padx=10, pady=10)
    frm.pack(fill="both", expand=True)

    tk.Label(frm, text="CSV").grid(row=0, column=0, sticky="w")
    tk.Entry(frm, textvariable=file_var, width=60).grid(row=0, column=1, sticky="we")
    tk.Button(frm, text="Browse…", command=browse).grid(row=0, column=2, padx=5)

    tk.Label(frm, text="Stim schedule").grid(row=1, column=0, sticky="w")
    tk.Label(frm, text="start (mV)").grid(row=2, column=0, sticky="w")
    tk.Entry(frm, textvariable=stim_start_var, width=10).grid(row=2, column=1, sticky="w")
    tk.Label(frm, text="step (mV)").grid(row=2, column=2, sticky="w")
    tk.Entry(frm, textvariable=stim_step_var, width=10).grid(row=2, column=3, sticky="w")
    tk.Label(frm, text="sweeps/step").grid(row=2, column=4, sticky="w")
    tk.Entry(frm, textvariable=sweeps_per_var, width=10).grid(row=2, column=5, sticky="w")

    tk.Label(frm, text="Stim time (ms)").grid(row=3, column=0, sticky="w")
    tk.Entry(frm, textvariable=stim_time_var, width=10).grid(row=3, column=1, sticky="w")

    tk.Label(frm, text="Windows (ms)").grid(row=4, column=0, sticky="w")
    r = 5
    for name, a, b in [
        ("Stim", stim_w1, stim_w2),
        ("M", m_w1, m_w2),
        ("H", h_w1, h_w2),
        ("RMS", rms_w1, rms_w2),
    ]:
        tk.Label(frm, text=name).grid(row=r, column=0, sticky="w")
        tk.Entry(frm, textvariable=a, width=10).grid(row=r, column=1, sticky="w")
        tk.Entry(frm, textvariable=b, width=10).grid(row=r, column=2, sticky="w")
        r += 1

    tk.Checkbutton(frm, text="M: use first peak pair (P1→N1)", variable=m_p1n1_on).grid(row=r, column=0, sticky="w")
    tk.Label(frm, text="opp max (ms)").grid(row=r, column=1, sticky="e")
    tk.Entry(frm, textvariable=m_opp_max_var, width=10).grid(row=r, column=2, sticky="w")
    r += 1

    tk.Checkbutton(frm, text="Add tiny X jitter", variable=jitter_on).grid(row=r, column=0, sticky="w")
    tk.Label(frm, text="jitter sd (mV)").grid(row=r, column=1, sticky="e")
    tk.Entry(frm, textvariable=jitter_sd, width=10).grid(row=r, column=2, sticky="w")
    r += 1

    tk.Checkbutton(frm, text="Show raw check plot", variable=raw_plot_on).grid(row=r, column=0, sticky="w")
    tk.Checkbutton(frm, text="Show H-Reflex Poly3 plot", variable=h_poly_on).grid(row=r, column=1, sticky="w")
    tk.Checkbutton(frm, text="Append InOutResults.txt", variable=write_txt_on).grid(row=r, column=2, sticky="w")
    tk.Checkbutton(frm, text="Save per-sweep summary CSV", variable=save_csv_on).grid(row=r, column=3, sticky="w")
    r += 1

    tk.Button(frm, text="Run fit", command=run, height=2).grid(row=r, column=0, columnspan=6, sticky="we", pady=10)

    frm.columnconfigure(1, weight=1)
    root.mainloop()


if __name__ == "__main__":
    gui()
