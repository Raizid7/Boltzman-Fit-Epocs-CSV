import os
import numpy as np
import pandas as pd
import tkinter as tk
from tkinter import filedialog, messagebox
from dataclasses import dataclass

import matplotlib.pyplot as plt
from scipy.optimize import least_squares
from scipy.stats import t as student_t


def boltzmann(x, max_out, x50, k):
    """3-parameter logistic (Boltzmann) function."""
    return max_out / (1.0 + np.exp(-(x - x50) / k))


def peak_to_peak(y):
    """Peak-to-peak amplitude ignoring NaNs."""
    return float(np.nanmax(y) - np.nanmin(y))


def rms_nan(y):
    """RMS ignoring NaNs."""
    y = np.asarray(y, dtype=float)
    y = y[np.isfinite(y)]
    if y.size == 0:
        return float("nan")
    return float(np.sqrt(np.mean(y * y)))


@dataclass
class Settings:
    # --- stimulation schedule (manual intensity rule) ---
    stim_start_mv: float = 0.2
    stim_step_mv: float = 0.3
    sweeps_per_step: int = 3

    # --- timing (ms) relative to stim at t=0 ---
    stim_time_ms: float = 0.0

    stim_start_ms: float = -5.0
    stim_stop_ms: float = 5.0

    m_start_ms: float = 10.0
    m_stop_ms: float = 25.0

    h_start_ms: float = 30.0
    h_stop_ms: float = 50.0

    rms_start_ms: float = -90.0
    rms_stop_ms: float = -10.0

    # --- auto-detect M/H windows ---
    auto_windows: bool = False
    # Search bands (ms) relative to stim; tune to your setup if needed
    m_search_start_ms: float = 5.0
    m_search_stop_ms: float = 30.0
    h_search_start_ms: float = 35.0
    h_search_stop_ms: float = 80.0
    # Sliding window length used to score candidate segments
    auto_win_len_ms: float = 12.0
    # Ignore a small margin at band edges
    auto_guard_ms: float = 2.0



    # Prefer the first strong response inside the M-band (helps when two responses exist)
    auto_m_first_fraction: float = 0.70  # pick earliest window with score >= fraction*best_in_band
    auto_noise_mult: float = 6.0         # minimum score must exceed noise_rms*mult

    # --- optional small X jitter to avoid duplicate X fit issues ---
    add_x_jitter: bool = True
    # MATLAB script adds randn(N,1)*0.1 to X *after* building StimAmpx.
    # Keep the same default so duplicate X values separate in the fit plot.
    x_jitter_sd_mv: float = 0.1

    # --- MATLAB-like extras ---
    show_raw_check_plot: bool = True
    show_h_poly_fit_plot: bool = True
    write_results_txt: bool = True
    results_txt_name: str = "InOutResults.txt"
    save_summary_csv: bool = True
    summary_csv_suffix: str = "_summary.csv"

    # --- confidence intervals ---
    ci_alpha: float = 0.05  # 0.05 => 95% CI


def build_x_manual(n_sweeps, stim_start_mv, stim_step_mv, sweeps_per_step):
    if sweeps_per_step <= 0:
        raise ValueError("sweeps_per_step must be > 0.")
    idx = np.arange(n_sweeps)
    level = idx // int(sweeps_per_step)
    return stim_start_mv + stim_step_mv * level


def masks_from_ms(t, stim_time_ms, start_ms, stop_ms):
    tr = t - (stim_time_ms / 1000.0)
    s0 = start_ms / 1000.0
    s1 = stop_ms / 1000.0
    return (tr >= s0) & (tr <= s1)



def _moving_mean(x, n):
    x = np.asarray(x, dtype=float)
    if n is None or int(n) <= 1:
        return x
    n = int(n)
    k = np.ones(n, dtype=float) / float(n)
    return np.convolve(x, k, mode="same")


def detect_m_h_windows_ms(t, sweeps, s: Settings):
    """Auto-detect M and H analysis windows.

    Uses a robust reference trace (median across sweeps after baseline removal),
    then selects the highest peak-to-peak segment within user-defined latency bands.

    Returns: (m_start_ms, m_stop_ms, h_start_ms, h_stop_ms)
    """
    t = np.asarray(t, dtype=float)
    sweeps = np.asarray(sweeps, dtype=float)

    dt = float(np.median(np.diff(t)))
    if not np.isfinite(dt) or dt <= 0:
        raise ValueError("Time column is invalid (dt<=0).")
    sf = 1.0 / dt

    # Baseline subtract each sweep using the RMS (pre-stim) window
    rms_mask = masks_from_ms(t, s.stim_time_ms, s.rms_start_ms, s.rms_stop_ms)
    if rms_mask.sum() < 3:
        raise ValueError("RMS window has too few samples for auto-detection baseline.")

    base = np.nanmean(sweeps[rms_mask, :], axis=0)  # per-sweep baseline
    sweeps0 = sweeps - base  # broadcast

    # Robust reference (median reduces outlier artifacts)
    ref = np.nanmedian(sweeps0, axis=1)


    # Noise estimate from pre-stim window on the reference trace
    noise_rms = rms_nan(ref[rms_mask])
    win_len = max(5, int(round((float(s.auto_win_len_ms) / 1000.0) * sf)))
    guard = max(0, int(round((float(s.auto_guard_ms) / 1000.0) * sf)))

    def best_window(search_start_ms, search_stop_ms, *, prefer_first=False, first_fraction=0.7, min_score=0.0):
        band_mask = masks_from_ms(t, s.stim_time_ms, search_start_ms, search_stop_ms)
        idx = np.where(band_mask)[0]
        if idx.size < win_len + 3:
            raise ValueError("Auto window search band is too small.")

        i_lo = int(idx[0] + guard)
        i_hi = int(idx[-1] - win_len - guard)
        if i_hi <= i_lo:
            raise ValueError("Auto window search band is too small after guard.")

        # Score candidate windows by peak-to-peak on the reference trace
        scores = np.full(i_hi - i_lo + 1, np.nan, dtype=float)
        for k, i0 in enumerate(range(i_lo, i_hi + 1)):
            seg = ref[i0 : i0 + win_len]
            scores[k] = float(np.nanmax(seg) - np.nanmin(seg))

        # Best in band (used both for default and for 'prefer_first' logic)
        finite = scores[np.isfinite(scores)]
        if finite.size == 0:
            raise ValueError("Auto window detection failed (no finite scores).")
        best_score = float(np.nanmax(finite))

        # Choose index
        chosen_i = None
        if prefer_first:
            thresh = max(float(min_score), float(first_fraction) * best_score)
            for k, i0 in enumerate(range(i_lo, i_hi + 1)):
                sc = scores[k]
                if np.isfinite(sc) and sc >= thresh:
                    chosen_i = i0
                    break
            # If nothing crosses threshold, fall back to the best window
            if chosen_i is None:
                chosen_i = int(i_lo + int(np.nanargmax(scores)))
        else:
            chosen_i = int(i_lo + int(np.nanargmax(scores)))

        # Convert sample window to ms relative to stim
        tr = t - (s.stim_time_ms / 1000.0)
        start_ms = float(tr[chosen_i] * 1000.0)
        stop_ms = float(tr[chosen_i + win_len - 1] * 1000.0)
        return start_ms, stop_ms

    m0, m1 = best_window(
        s.m_search_start_ms,
        s.m_search_stop_ms,
        prefer_first=True,
        first_fraction=float(s.auto_m_first_fraction),
        min_score=float(noise_rms) * float(s.auto_noise_mult),
    )
    h0, h1 = best_window(
        s.h_search_start_ms,
        s.h_search_stop_ms,
        prefer_first=False,
        min_score=float(noise_rms) * float(s.auto_noise_mult),
    )
    return m0, m1, h0, h1

def _fit_boltzmann_least_squares(x, y, p0, bounds):
    lower, upper = bounds

    def resid(p):
        return boltzmann(x, *p) - y

    res = least_squares(
        resid,
        x0=np.asarray(p0, dtype=float),
        bounds=(np.asarray(lower, dtype=float), np.asarray(upper, dtype=float)),
        max_nfev=200000,
    )
    return res


def _cov_and_ci_from_jacobian(res, alpha=0.05):
    """Approximate covariance + (1-alpha) CI from least_squares result."""
    r = np.asarray(res.fun, dtype=float)
    J = np.asarray(res.jac, dtype=float)
    m = r.size
    p = J.shape[1]

    if m <= p:
        return None, None

    # residual variance estimate
    s_sq = float(np.dot(r, r) / (m - p))

    # covariance ~ s^2 * inv(J^T J)
    try:
        JTJ = J.T @ J
        cov = np.linalg.inv(JTJ) * s_sq
    except np.linalg.LinAlgError:
        return None, None

    se = np.sqrt(np.diag(cov))
    dof = m - p
    tcrit = float(student_t.ppf(1.0 - alpha / 2.0, dof))
    beta = np.asarray(res.x, dtype=float)
    ci = np.vstack([beta - tcrit * se, beta + tcrit * se]).T
    return cov, ci



def fit_h_reflex_poly3(x, y, normalize=True):
    """MATLAB-like Poly3 fit for H-reflex (optionally normalized).

    Returns:
        dict with keys:
          - coeffs_z: poly coefficients highest->lowest in normalized space (z)
          - mu, sigma: normalization parameters (if normalize else 0,1)
          - r2, rmse: goodness-of-fit metrics on the input points
          - x_grid, y_grid: smooth curve for plotting
          - y_hat: fitted values on x
    """
    x = np.asarray(x, dtype=float)
    y = np.asarray(y, dtype=float)
    ok = np.isfinite(x) & np.isfinite(y)
    x = x[ok]
    y = y[ok]
    if x.size < 4:
        raise ValueError("Not enough points for Poly3 fit (need >= 4).")

    if normalize:
        mu = float(np.mean(x))
        sigma = float(np.std(x, ddof=0))
        if not np.isfinite(sigma) or sigma == 0.0:
            sigma = 1.0
        z = (x - mu) / sigma
    else:
        mu, sigma = 0.0, 1.0
        z = x

    coeffs_z = np.polyfit(z, y, deg=3)
    p = np.poly1d(coeffs_z)
    y_hat = p(z)

    ss_res = float(np.sum((y - y_hat) ** 2))
    ss_tot = float(np.sum((y - float(np.mean(y))) ** 2))
    r2 = float("nan") if ss_tot == 0.0 else 1.0 - ss_res / ss_tot
    rmse = float(np.sqrt(ss_res / max(1, y.size)))

    # Smooth curve
    x_grid = np.linspace(float(np.min(x)), float(np.max(x)), 400)
    z_grid = (x_grid - mu) / sigma if normalize else x_grid
    y_grid = p(z_grid)

    return {
        "coeffs_z": coeffs_z,
        "mu": mu,
        "sigma": sigma,
        "r2": r2,
        "rmse": rmse,
        "x_grid": x_grid,
        "y_grid": y_grid,
        "y_hat": y_hat,
        "x_data": x,
        "y_data": y,
    }


def run_fit(csv_path: str, s: Settings):
    # Expect headerless numeric CSV:
    # column 0 = time (seconds)
    # columns 1..N = sweep signals
    df = pd.read_csv(csv_path, header=None)
    arr = df.to_numpy(dtype=float)

    if arr.shape[1] < 3:
        raise ValueError("CSV must be: time column + at least 2 sweep columns.")

    t = arr[:, 0]
    sweeps = arr[:, 1:]
    n_samples, n_sweeps = sweeps.shape

    dt = float(np.median(np.diff(t)))
    if not np.isfinite(dt) or dt <= 0:
        raise ValueError("Time column is invalid (dt<=0).")
    sf = 1.0 / dt

    # Optionally auto-detect M/H windows from the data
    if getattr(s, 'auto_windows', False):
        m0, m1, h0, h1 = detect_m_h_windows_ms(t, sweeps, s)
        s = Settings(**{**s.__dict__, 'm_start_ms': m0, 'm_stop_ms': m1, 'h_start_ms': h0, 'h_stop_ms': h1})

    stim_mask = masks_from_ms(t, s.stim_time_ms, s.stim_start_ms, s.stim_stop_ms)
    m_mask = masks_from_ms(t, s.stim_time_ms, s.m_start_ms, s.m_stop_ms)
    h_mask = masks_from_ms(t, s.stim_time_ms, s.h_start_ms, s.h_stop_ms)
    rms_mask = masks_from_ms(t, s.stim_time_ms, s.rms_start_ms, s.rms_stop_ms)

    for name, m in [("Stim", stim_mask), ("M", m_mask), ("H", h_mask), ("RMS", rms_mask)]:
        if m.sum() < 3:
            raise ValueError(f"{name} window has too few samples.")

    # Stimulation intensities
    # X_raw is the "clean" stimulation axis (MATLAB: StimAmpx)
    X_raw = build_x_manual(n_sweeps, s.stim_start_mv, s.stim_step_mv, s.sweeps_per_step)

    # X_fit is used for fitting AND for the fit plot points (MATLAB: X = StimAmpx + randn()*0.1)
    X_fit = X_raw.copy()
    if s.add_x_jitter:
        X_fit = X_fit + np.random.randn(*X_fit.shape) * float(s.x_jitter_sd_mv)

    # Extract per-sweep metrics
    Mampx = np.array([peak_to_peak(sweeps[m_mask, i]) for i in range(n_sweeps)], dtype=float)
    Hampx = np.array([peak_to_peak(sweeps[h_mask, i]) for i in range(n_sweeps)], dtype=float)
    EMGrmsx = np.array([rms_nan(sweeps[rms_mask, i]) for i in range(n_sweeps)], dtype=float)

    # Match MATLAB scaling to mV
    scale_to_mV = 1000.0
    Mamp = Mampx * scale_to_mV
    Hamp = Hampx * scale_to_mV
    EMGrms = EMGrmsx * scale_to_mV

    # --- H-Reflex Poly3 fit (MATLAB: fit(..., 'Poly3', 'Normalize','on')) ---
    h_poly = None
    if s.show_h_poly_fit_plot:
        try:
            h_poly = fit_h_reflex_poly3(X_raw, Hamp, normalize=True)

            plt.figure()
            plt.plot(h_poly["x_grid"], h_poly["y_grid"], "-", linewidth=1, label="Poly3 fit (normalized)")
            plt.plot(h_poly["x_data"], h_poly["y_data"], "o", label="Hamp vs. X")
            plt.xlabel("Stimulation intensity (mV)")
            plt.ylabel("H amplitude (mV)")
            plt.title(f"H-Reflex (Poly3) | R²={h_poly['r2']:.3f} | RMSE={h_poly['rmse']:.3g}")
            plt.grid(True)
            plt.legend(loc="upper right")
            plt.tight_layout()
        except Exception as _e:
            # Keep main workflow running even if the polynomial fit fails.
            h_poly = None


    # Fit only finite points
    ok = np.isfinite(X_fit) & np.isfinite(Mamp)
    Xv = X_fit[ok]
    Yv = Mamp[ok]
    if Xv.size < 6:
        raise ValueError("Not enough valid sweeps for fit.")

    # Initial guesses (close to MATLAB logic)
    max0 = float(np.nanmax(Yv))
    i_max = int(np.nanargmax(Yv))
    x50_0 = float(Xv[i_max] / 2.0)  # MATLAB used X(I)/2
    x_range = float(np.nanmax(Xv) - np.nanmin(Xv))
    k0 = max(x_range / 10.0, 1e-6)
    p0 = [max0, x50_0, k0]

    pad = 0.25 * (x_range + 1e-9)
    lower = [0.0, float(np.nanmin(Xv) - pad), 1e-9]
    upper = [np.inf, float(np.nanmax(Xv) + pad), np.inf]

    # Fit using least_squares to get residuals + Jacobian
    res = _fit_boltzmann_least_squares(Xv, Yv, p0=p0, bounds=(lower, upper))
    beta = res.x
    R = res.fun
    J = res.jac

    pcov, ci = _cov_and_ci_from_jacobian(res, alpha=s.ci_alpha)

    # Create smooth curve (MATLAB: round(min):0.1:round(max))
    x_grid = np.arange(np.round(float(np.nanmin(Xv))), np.round(float(np.nanmax(Xv))) + 0.0001, 0.1)
    y_grid = boltzmann(x_grid, *beta)

    # --- Raw check plot (Hamp & Mamp vs stim) ---
    if s.show_raw_check_plot:
        plt.figure()
        plt.plot(X_raw, Hamp, "o", label="H-reflex (p-p)")
        plt.plot(X_raw, Mamp, "o", label="M-wave (p-p)")
        plt.xlabel("Stimulation intensity (mV)")
        plt.ylabel("Amplitude (mV)")
        plt.title("Raw check: H and M vs stimulation")
        plt.legend()
        plt.tight_layout()

    # --- Fit plot ---
    plt.figure()
    plt.plot(x_grid, y_grid, "-", linewidth=1, label="Boltz fit (M)")
    # Use jittered X like MATLAB so duplicates separate in this plot.
    plt.plot(X_fit, Mamp, "o", label="M-wave (p-p)")
    plt.plot(X_fit, Hamp, "o", label="H-reflex (p-p)")
    plt.xlabel("Stimulation intensity (mV)")
    plt.ylabel("Amplitude (mV)")
    plt.title(f"{os.path.basename(csv_path)}\nSF={sf:.1f} Hz | sweeps={n_sweeps}")
    plt.legend()
    plt.tight_layout()
    plt.show()

    # --- Save results (MATLAB-style) ---
    out_dir = os.path.dirname(os.path.abspath(csv_path))
    txt_path = os.path.join(out_dir, s.results_txt_name)

    if s.write_results_txt:
        with open(txt_path, "a", encoding="utf-8") as f:
            f.write(f"{os.path.abspath(csv_path)}\t")
            f.write("\t".join([f"{v:.8f}" for v in beta]))
            f.write("\n")

    # --- Save per-sweep summary table ---
    summary_path = None
    if s.save_summary_csv:
        base, _ = os.path.splitext(os.path.basename(csv_path))
        summary_path = os.path.join(out_dir, base + s.summary_csv_suffix)
        pd.DataFrame(
            {
                "sweep": np.arange(1, n_sweeps + 1),
                "stim_mv": X_raw,
                "stim_mv_fit_jittered": X_fit,
                "M_pp_mV": Mamp,
                "H_pp_mV": Hamp,
                "baseline_rms_mV": EMGrms,
            }
        ).to_csv(summary_path, index=False)

    return {
        "sf": sf,
        "beta": beta,
        "residuals": R,
        "jacobian": J,
        "pcov": pcov,
        "ci": ci,
        "h_poly": h_poly,
        "xstim": x_grid,
        "fit": y_grid,
        "txt_path": txt_path if s.write_results_txt else None,
        "summary_path": summary_path,
        "table": pd.DataFrame(
            {
                "sweep": np.arange(1, n_sweeps + 1),
                "stim_mv": X_raw,
                "stim_mv_fit_jittered": X_fit,
                "M_pp_mV": Mamp,
                "H_pp_mV": Hamp,
                "baseline_rms_mV": EMGrms,
            }
        ),
    }


def gui():
    root = tk.Tk()
    root.title("Boltzmann Fit (MATLAB-like extras)")

    s = Settings()

    file_var = tk.StringVar(value="")

    stim_start_var = tk.StringVar(value=str(s.stim_start_mv))
    stim_step_var = tk.StringVar(value=str(s.stim_step_mv))
    sweeps_per_var = tk.StringVar(value=str(s.sweeps_per_step))

    stim_time_var = tk.StringVar(value=str(s.stim_time_ms))
    stim_w1 = tk.StringVar(value=str(s.stim_start_ms))
    stim_w2 = tk.StringVar(value=str(s.stim_stop_ms))
    m_w1 = tk.StringVar(value=str(s.m_start_ms))
    m_w2 = tk.StringVar(value=str(s.m_stop_ms))
    h_w1 = tk.StringVar(value=str(s.h_start_ms))
    h_w2 = tk.StringVar(value=str(s.h_stop_ms))
    rms_w1 = tk.StringVar(value=str(s.rms_start_ms))
    rms_w2 = tk.StringVar(value=str(s.rms_stop_ms))

    jitter_on = tk.IntVar(value=1 if s.add_x_jitter else 0)
    jitter_sd = tk.StringVar(value=str(s.x_jitter_sd_mv))

    raw_plot_on = tk.IntVar(value=1 if s.show_raw_check_plot else 0)
    h_poly_on = tk.IntVar(value=1 if s.show_h_poly_fit_plot else 0)
    write_txt_on = tk.IntVar(value=1 if s.write_results_txt else 0)
    save_csv_on = tk.IntVar(value=1 if s.save_summary_csv else 0)
    auto_on = tk.IntVar(value=1 if s.auto_windows else 0)


    def browse():
        p = filedialog.askopenfilename(
            title="Select CSV",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
        )
        if p:
            file_var.set(p)

    def run():
        path = file_var.get().strip()
        if not path:
            messagebox.showerror("Error", "Pick a CSV first.")
            return

        try:
            settings = Settings(
                stim_start_mv=float(stim_start_var.get()),
                stim_step_mv=float(stim_step_var.get()),
                sweeps_per_step=int(float(sweeps_per_var.get())),
                stim_time_ms=float(stim_time_var.get()),
                stim_start_ms=float(stim_w1.get()),
                stim_stop_ms=float(stim_w2.get()),
                m_start_ms=float(m_w1.get()),
                m_stop_ms=float(m_w2.get()),
                h_start_ms=float(h_w1.get()),
                h_stop_ms=float(h_w2.get()),
                rms_start_ms=float(rms_w1.get()),
                rms_stop_ms=float(rms_w2.get()),
                add_x_jitter=bool(jitter_on.get()),
                x_jitter_sd_mv=float(jitter_sd.get()),
                show_raw_check_plot=bool(raw_plot_on.get()),
                show_h_poly_fit_plot=bool(h_poly_on.get()),
                write_results_txt=bool(write_txt_on.get()),
                save_summary_csv=bool(save_csv_on.get()),
                auto_windows=bool(auto_on.get()),
            )
        except Exception as e:
            messagebox.showerror("Error", f"Bad input: {e}")
            return

        try:
            out = run_fit(path, settings)
            beta = out["beta"]
            ci = out["ci"]

            lines = [
                f"SF = {out['sf']:.2f} Hz",
                "",
                "beta:",
                f"  max_out = {beta[0]:.6g}",
                f"  x50     = {beta[1]:.6g}",
                f"  k       = {beta[2]:.6g}",
            ]

            if ci is not None:
                lines += [
                    "",
                    f"{int((1.0 - settings.ci_alpha) * 100)}% CI:",
                    f"  max_out: [{ci[0,0]:.6g}, {ci[0,1]:.6g}]",
                    f"  x50    : [{ci[1,0]:.6g}, {ci[1,1]:.6g}]",
                    f"  k      : [{ci[2,0]:.6g}, {ci[2,1]:.6g}]",
                ]

            if out.get("txt_path"):
                lines += ["", f"Appended: {out['txt_path']}"]
            if out.get("summary_path"):
                lines += [f"Saved: {out['summary_path']}"]

            messagebox.showinfo("Fit result", "\n".join(lines))

        except Exception as e:
            messagebox.showerror("Error", str(e))

    frm = tk.Frame(root, padx=10, pady=10)
    frm.pack(fill="both", expand=True)

    tk.Label(frm, text="CSV").grid(row=0, column=0, sticky="w")
    tk.Entry(frm, textvariable=file_var, width=60).grid(row=0, column=1, sticky="we")
    tk.Button(frm, text="Browse…", command=browse).grid(row=0, column=2, padx=5)

    tk.Label(frm, text="Stim schedule").grid(row=1, column=0, sticky="w")
    tk.Label(frm, text="start (mV)").grid(row=2, column=0, sticky="w")
    tk.Entry(frm, textvariable=stim_start_var, width=10).grid(row=2, column=1, sticky="w")
    tk.Label(frm, text="step (mV)").grid(row=2, column=2, sticky="w")
    tk.Entry(frm, textvariable=stim_step_var, width=10).grid(row=2, column=3, sticky="w")
    tk.Label(frm, text="sweeps/step").grid(row=2, column=4, sticky="w")
    tk.Entry(frm, textvariable=sweeps_per_var, width=10).grid(row=2, column=5, sticky="w")

    tk.Label(frm, text="Stim time (ms)").grid(row=3, column=0, sticky="w")
    tk.Entry(frm, textvariable=stim_time_var, width=10).grid(row=3, column=1, sticky="w")

    tk.Label(frm, text="Windows (ms)").grid(row=4, column=0, sticky="w")
    r = 5
    for name, a, b in [
        ("Stim", stim_w1, stim_w2),
        ("M", m_w1, m_w2),
        ("H", h_w1, h_w2),
        ("RMS", rms_w1, rms_w2),
    ]:
        tk.Label(frm, text=name).grid(row=r, column=0, sticky="w")
        tk.Entry(frm, textvariable=a, width=10).grid(row=r, column=1, sticky="w")
        tk.Entry(frm, textvariable=b, width=10).grid(row=r, column=2, sticky="w")
        r += 1

    tk.Checkbutton(frm, text="Auto-detect M/H windows", variable=auto_on).grid(row=r, column=0, sticky="w")
    r += 1

    tk.Checkbutton(frm, text="Add tiny X jitter", variable=jitter_on).grid(row=r, column=0, sticky="w")
    tk.Label(frm, text="jitter sd (mV)").grid(row=r, column=1, sticky="e")
    tk.Entry(frm, textvariable=jitter_sd, width=10).grid(row=r, column=2, sticky="w")
    r += 1

    tk.Checkbutton(frm, text="Show raw check plot", variable=raw_plot_on).grid(row=r, column=0, sticky="w")
    tk.Checkbutton(frm, text="Show H-Reflex Poly3 plot", variable=h_poly_on).grid(row=r, column=1, sticky="w")
    tk.Checkbutton(frm, text="Append InOutResults.txt", variable=write_txt_on).grid(row=r, column=2, sticky="w")
    tk.Checkbutton(frm, text="Save per-sweep summary CSV", variable=save_csv_on).grid(row=r, column=3, sticky="w")
    r += 1

    tk.Button(frm, text="Run fit", command=run, height=2).grid(row=r, column=0, columnspan=6, sticky="we", pady=10)

    frm.columnconfigure(1, weight=1)
    root.mainloop()


if __name__ == "__main__":
    gui()
